# 2.2 Exercises for Section 2.2

### 2.2.1

Consider the context-free grammar:

S -> S S + | S S * | a

1. Show how the string aa+a* can be generated by this grammar.
2. Construct a parse tree for this string.
3. What language does this grammar generate? Justify your answer.

#### answer

1. `S` -> `S` S * -> `S` S + S * -> a `S` + S * -> a a + `S` * -> a a + a *
2. ![Syntax tree](https://raw.github.com/fool2fish/dragon-book-practice-answer/master/ch02/2.2/assets/2.2.1-2.png)
3. L = {Postfix expression consisting of digits, plus and multiple signs}

### 2.2.2

What language is generated by the following grammars? In each case justify your answer.

1. S -> 0 S 1 | 0 1
2. S -> + S S | - S S | a
3. S -> S ( S ) S | ε
4. S -> a S b S | b S a S | ε
5. ⧗ S -> a | S + S | S S | S * | ( S ) 

#### answer

1. L = {0<sup>n</sup>1<sup>n</sup> | n>=1}
2. L = {Prefix expression consisting of plus and minus signs}
3. L = {Matched brackets of arbitrary arrangement and nesting, includes ε}
4. L = {String has the same amount of a and b, includes ε}
5. ？
（５．normal expression consisting of plus \ multiple and matched brackets signs 

    added by denuo98）

### 2.2.3

Which of the grammars in Exercise 2.2.2 are ambiguous

#### answer

1. No
2. No
3. Yes
    
   ![ambiguous parse tree](https://raw.github.com/fool2fish/dragon-book-practice-answer/master/ch02/2.2/assets/2.2.3-3.png)
    
4. Yes

    ![ambiguous parse tree](https://raw.github.com/fool2fish/dragon-book-practice-answer/master/ch02/2.2/assets/2.2.3-4.png)
    
5. Yes

    ![ambiguous parse tree](https://raw.github.com/fool2fish/dragon-book-practice-answer/master/ch02/2.2/assets/2.2.3-5.png)
    
### 2.2.4

Construct unambiguous context-free grammars for each of
the following languages. In each case show that your grammar is correct.

1. Arithmetic expressions in postfix notation.
2. Left-associative lists of identifiers separated by commas.
3. Right-associative lists of identifiers separated by commas.
4. Arithmetic expressions of integers and identifiers with the four binary operators +, - , *, /.

#### answer

```
1. E -> E E op | num

2. list -> list , id | id

3. list -> id , list | id

4. expr -> expr + term | expr - term | term
   term -> term * factor | term / factor | factor
   factor -> id | num | (expr)

5. expr -> expr + term | expr - term | term
   term -> term * unary | term / unary | unary
   unary -> + factor | - factor
   factor - > id | num | (expr)
```
   
### 2.2.5 

1. Show that all binary strings generated by the following grammar have values divisible by 3. Hint. Use induction on the number of nodes in a parse tree.

    num -> 11 | 1001 | num 0 | num num

2.  Does the grammar generate all binary strings with values divisible by 3?

#### answer

1. prove

    any string derived from the grammar can be considered to be a sequence consisting of 11, 1001 and 0, and not prefixed with 0. 
    
    the sum of this string is:

    sum 

    = Σ<sub>n</sub> (2<sup>1</sup> + 2<sup>0</sup>) * 2 <sup>n</sup> + Σ<sub>m</sub> (2<sup>3</sup> + 2<sup>0</sup>) * 2<sup>m</sup>

    = Σ<sub>n</sub> 3 * 2 <sup>n</sup> + Σ<sub>m</sub> 9 * 2<sup>m</sup>

    It is obviously can divisible by 3.

2. No. Consider string "10101", it is divisible by 3, but cannot derived from the grammar.

    **Question:** any general prove?

### 2.2.6

Construct a context-free grammar for roman numerals.

**Note:** we just consider a subset of roman numerals which is less than 4k.

#### answer

[wikipedia: Roman_numerals](http://en.wikipedia.org/wiki/Roman_numerals)
- via wikipedia, we can categorize the single noman numerals into 4 groups:

    ```
    I, II, III | I V | V, V I, V II, V III | I X
    ```

    then get the production:
    
    ```
    digit -> smallDigit | I V | V smallDigit | I X
    smallDigit -> I | II | III | ε
    ```

- and we can find a simple way to map roman to arabic numerals. For example:

    - XII => X, II => 10 + 2 => 12
    - CXCIX => C, XC, IX => 100 + 90 + 9 => 199
    - MDCCCLXXX => M, DCCC, LXXX => 1000 + 800 + 80 => 1880

- via the upper two rules, we can derive the production:

    romanNum -> thousand hundred ten digit

    thousand -> M | MM | MMM | ε 

    hundred -> smallHundred | C D | D smallHundred | C M

    smallHundred -> C | CC | CCC  | ε

    ten -> smallTen | X L | L smallTen | X C

    smallTen -> X | XX | XXX | ε

    digit -> smallDigit | I V | V smallDigit | I X

    smallDigit -> I | II | III  | ε
    
